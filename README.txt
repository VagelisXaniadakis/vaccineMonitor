111511170280
Χανιαδάκης Ευάγγελος

1η εργασία στο μάθημα Προγραμματισμός Συστήματος - Κ24 
vaccineMonitor

προτεινόμενη εντολή εκτέλεσης όταν βρισκόμαστε μέσα στο /src: make -s cleanall all run 

προτεινόμενη εντολή εκτέλεσης όταν βρισκόμαστε στο αρχικό directory: ./run.sh
( ή ./run.sh anotherInputFile, υποχρεωτική προυπόθεση το anotherInputFile να βρίσκεται αποθηκεύμενο υπό το /script subdirectory για να λειτουργήσει αυτό το scriptακι)

Έχω χωρίσει το αρχικό directory σε 3 subdirectories:
    
    Έχω το subdir /script όπου φυλάω μέσα το script testFile.sh που ζητείται από την εκφώνηση και υλοποιεί ακριβώς την αφαίρεση τα ζητούμενα οπότε δεν θα επεκταθώ, αλλά και τα απαραίτητα αρχεία που χρειάζεται για να εκτελεστεί. Το countriesFile, το virusesFile αλλά και το smallcountriesFile και το smallvirusesFile που είναι αυτά που χρησιμοποιώ κατα βάσην (έχουν λιγότερα δεδομένα) για να έχω πιο συμπαγή πληροφορία και να είναι πιο εμφανείς οι λειτουργίες του vaccineMonitor.
    Το output του testFile.sh είναι το inputFile και παράγεται και αυτό κάτω από το συγκεκριμένο subdir. Κάθε φορά που καλείται το script διαγράφεται το inputFile για να ξαναδημιουργηθεί. 
    Κάτι βασικό που θέλω να πω και σχετικό με το inputFile είναι ότι το vaccineMonitor βγάζει segmentation fault εκεί όπου ελέγχει για duplicates, αν λάβει citizenID=0, δεν μπορώ να καταλάβω γιατί, οπότε αν τυχόν υπάρχει record με citizenID==0 να το διαγράψετε.

    Το επόμενο subdir είναι το /lib όπου αποτελείται από δύο subdirs, το /structures, που φυλάει μέσα τα απαραίτητα structs για την εφαρμογή και το /headers όπου φυλάει τις βιβλιοθήκες της εφαρμογής.
    
    Τέλος, υπάρχει και το subdir /src όπου φυλάει όλα τα source files του προγράμματος στα οποία θα αναφερθώ παρακάτω.
    
Υπό το αρχικό directory φυλάγεται και ένα scriptάκι ονόματι run.sh . Η λειτουργικότητα αυτού του script είναι αν καλεστεί χωρίς ορίσματα να καλέσει την make όπου θα διαγράψει κάθε προσωρινό αρχείο, θα δημιουργήσει ένα inputFile, θα κάνει compile και θα τρέξει το vaccineMonitor. 
Αλλιώς αν καλεστεί με κάποιο όρισμα, θα καλέστει η make όπου θα διαγράψει κάθε προσωρινό αρχείο, θα κάνει compile και θα τρέξει το vaccineMonitor με inputFile το όρισμα που δόθηκε στο script.


Τώρα, υπό το /src subdirectory έχουμε τα εξής αρχεία:

    Αρχικά έχουμε το Makefile, με τις εξής επιλογές:
        all             : για να δημιουργηθεί νέο inputFile και να γίνει συνολικό compile και να παραχθεί το 
                        εκτελέσιμο vaccineMonitor
        vaccineMonitor  : για να γίνει συνολικό compile και να παραχθεί το εκτελέσιμο
                        vaccineMonitor
        script          : για να δημιουργηθεί νέο inputFile
        run             : για να τρέξει το εκτελέσιμο που έχει παραχθεί (με default ορίσματα που έχω δηλώσει στο 
                        Makefile εκτός αν ορίσει ο χρήστης κάτι διαφορετικό)
        valgrind        : για να τρέξει το εκτελέσιμο πάνω στο valgrind για έλεγχο τυχόν σφαλμάτων στη μνήμη
        clean           : για να διαγραφούν όλα τα object files αλλά και το εκτελέσιμο
        cleanall        : για να διαγραφούν όλα τα object files, το εκτελέσιμο, το inputFile, και τυχόν το      
                        txt-file που παράχθηκε από την εκτέλεση του valgrind.
    Έπίσης προαιρετικά μπορούν να δοθούν και τα εξής ορίσματα (υπάρχουν ορισμένες default τιμές, οπότε δεν είναι υποχρεωτικό):
        -για debug=1 θα γίνει compile με ta κατάλληλα flags 
        -για debug=2 δεν θα εμφανιστούν καθόλου τυχόν warnings
        -τα virusesfile, countriesfile, numlines και duplicatesallowed ορίσματα σε περίπτωση που δοθούν είναι τα 
            ονόματα αρχείων που θα περαστούν ως ορίσματα στο script. υπάρχουν ήδη default ορισμένα στο Makefile, αλλά σε περίπτωση που θέλουμε να ορίσουμε διαφορετικά θα πρέπει να το ορίσουμε ρητά. 
            (π.χ. make all virusesfile=hugeVirusesFile countriesfile=hugeCountriesFile numlines=1000 duplicatesallowed=0)
        -το inputfile ορίζει το όνομα του αρχείου που θα δοθεί ως inputFile στην vaccineMonitor
            (π.χ. make all inputfile=1MInputFile)
        -το bloomsize ορίζει το όρισμα bloomSize που θα δοθεί στην vaccineMonitor
            (π.χ. make all bloomsize=1000)
    Επαναλαμβάνω πως έχουν δοθεί default τιμές για όλα αυτά και είναι προαιρετικό να τα αλλάξουμε.
                        
    Το vaccineMonitor.c, που αποτελέι την main του προγράμματος, κάνει μόνο τις απαραίτητες αρχικοποιήσεις και καλεί συναρτήσεις των οποίων η λειτουργικότητα εξηγείται επαρκώς με σχόλια, πάνω στο αρχείο.
    Αυτό που θα χρειαστεί να επιστήσω την προσοχή σας επάνω είναι η ύπαρξη ενός struct το οποίο δεν ζητείται από την εκφώνηση, αλλά έχω δημιουργήσει εγώ για να φροντίσω το πρόγραμμα μου να είναι πιο ευανάγνωστο αλλά και αφαιρετικό. Μιλώ για την δομή DataPointer της οποίας δημιουργώ ένα μόνο αντικείμενο, το Universal. Αυτό φυλάει μέσα, δείκτες σε όλες τις δομές αλλά και τις απαραίτητες πληροφορίες του προγράμματος οι οποίες χρησιμοποιούνται πολύ συχνά. Με αυτό καταφέρνω να έχω πιο ευαναάγνωστες συναρτήσεις με αρκετά λιγότερα ορίσματα. Κάτι ακόμη βασικό είναι ότι έχω 3 πίνακες συμβολοσειρών: virusData, countryData & vacced, όπου φυλάω τις αντίστοιχες πληροφορίες (ιοί, χώρες, "YES" & "NO") μοναδική φορά και μετά δειχνώ με pointers εκεί για την αποφυγή επανάληψης πληροφορίας.
    
    Επίσης, έχουμε το αρχείο vaccineMonitorUtil.c, που υλοποιεί τις βασικές συναρτήσεις που κρύβονται κάτω από την main. 
        Αυτές οι συναρτήσεις καλούνται άμεσα από την main:
            -Έχουμε την parametersCheck που κοιτάει τις παραμέτρους και ελέγχει για την ορθότητα αυτών.
            -Έπειτα είναι η parseInputFile, όπου διαβάζει το inputFile που δόθηκε και αποθηκεύει τα records σε hashTable και αρχικοποιεί τις κατάλληλες δομές.
            -Έπειτα έχουμε την storeDataIntoDatatypes όπου διαβάζει τα αποθηκευμένα records στο hashTable και εισάγει την απαραίτητη πληροφορία στην skipList και το bloomFilter.
            -Τέλος, έχουμε την readInputFromKeyboard η οποία υλοποιεί το command-line του vaccineMonitor, το μέρος δηλαδή όπου μετά την ανάγνωση και κατάλληλη επεξεργασία του αρχείου η εφαρμογή περιμένει εντολή από τον χρήστη για να κάνει κάτι.
        Παρακάτω έχουμε τις συναρτήσεις που θα καλεστούν από την readInputFromKeyboard ανάλογα με την προτίμηση του χρήστη και υλοποιούν ακριβώς τα ζητούμενα της εκφώνησης:
            -η vaccineStatusBloom θα καλεστεί αν δοθεί το όρισμα /vaccineStatusBloom
            -η vaccineStatus θα καλεστεί αν δοθεί το όρισμα /vaccineStatus
            -η populationStatus θα καλεστεί αν δοθεί το όρισμα /populationStatus
            -η popStatusByAge θα καλεστεί αν δοθεί το όρισμα /popStatusByAge
            -η insertCitizenRecord θα καλεστεί αν δοθεί το όρισμα /insertCitizenRecord
            -η vaccinateNow θα καλεστεί αν δοθεί το όρισμα /vaccinateNow
            -η list_nonVaccinated_Persons θα καλεστεί αν δοθεί το όρισμα /list-nonVaccinated-Persons
            -η exitNow θα καλεστεί αν δοθεί το όρισμα /exit το οποίο θα αποδεσμέυσει όλες τις δομές, έπειτα θα παραδωθεί ο έλεγχος στην main και το πρόγραμμα θα τερματίσει.
    
    Έπειτα υπάρχει το αρχείο myLib.c , όπου υπάρχουν οι συναρτήσεις των οποίων η λειτουργικότητα εξηγείται επαρκώς με σχόλια, αλλά θα χρειαστεί να επεκταθώ λιγό παραπάνω στην λειτουργικότητα των εξής δύο:
        Έχουμε την virus_exists η οποία καλείται όταν λάμβάνουμε κάποιο νέο record προς καταχώρηση (είτε από το inputFile, είτε από εντολή αργότερα). Αυτή ελέγχει αν τα δωθέντα virusName και country υπάρχουν αποθηκευμένα στους πίνακες (virusData και countryData, για τους οποίους μιλήσαμε παραπάνω), κι αν όχι τα αποθηκεύει. Επίσης πληροφορεί την συνάρτηση που την κάλεσε για την τοποθεσία του συγκεκριμένου virus στον virusData πίνακα και για την τοποθεσία του συγκεκριμένου country στον countryData πίνακα. Τέλος, θα επιστρέψει 1, αν προυπήρχε ο ιός αποθηκευμένος, και 0, αν όχι.
        
        Τέλος, έχουμε την create_datatypes, η οποία θα καλεστεί μετά την virus_exists (αν επιστρέψει 0, γιατί σημαίνει πως πρώτη φορά βλέπουμε αυτό τον ιό άρα θα χρειαστεί να δεσμεύσουμε τις απαραίτητες δομές). Η λειτουργικότητα της είναι να δημιουργεί 1 bloomFilter και 2 skipLists, τις απαραίτητες δομές δηλαδή για έναν ιό.
    
    Επίσης υπάρχει το αρχείο hashFunctions.c , το οποίο φυλάει τις hash συναρτήσεις.
    
    Επίσης, υπάρχει το αρχείο hashTable.c , το οποίο έχει τις εξής συναρτήσεις:
        -Την insertAt_hashtable η οποία κάνει το προφανές και επιστρέφει δείκτη στο νεοεισαχθέν record.
        -Έχουμε την exportFrom_hashtable, η οποία μας δίνει απαραίτητες πληροφορίες για κάποιο συγκεκριμένο record που υπάρχει στο hashTable, χωρίς όμως να το αλλοιώνει.
        -Έχουμε την alter_hashNode που αλλοιώνει ένα record κατά έναν συγκεριμένο τρόπο.
        -Έχουμε την existsIn_hashtable η οποία χρησιμοποιείται όταν διαβάζουμε ένα νέο record, για την αποφυγή αποθήκευσης duplicate. Ο έλεγχος θα βγει θετικός αν το citizenID και το virusName είναι ίδια.
        -Τέλος, υπάρχει η free_hashtable που καλείται στο τέλος για την αποδέσμευση της μνήμης που φυλάει η δομή.
        
    Έπειτα υπάρχει το αρχείο bloomFilter.c , που περιέχει 3 συναρτήσεις, μια για να εισάγουμε αντικείμενα στο bloomFilter, μια για να ελέγχουμε αν υπάρχει κάποιο αντικείμενο στο bloomFilter, και μια για να αποδεσμεύουμε την μνήμη που έχει δεσμευθεί για αυτή τη δομή. Δεν έχω δημιουργήσει κάποιο struct για το bloomFilter αφού είναι ένας σκέτος char πίνακας.
    
    Τέλος, έχουμε το αρχείο skipList.c το οποίο έχει τις εξής συναρτήσεις:
        -Tην insertAt_skipList, η οποία εισάγει ένα αντικείμενο στην καθορισμένη skipList επιλέγοντας με τυχαίο τρόπο το max_level που θα είναι ορατό. 
        -Υπάρχει η deleteFrom_skipList, που διαγράφει κάποιο κόμβο από τη skipList και αποδεσμέυει τη μνήμη που κρατάει, και επιστρέφει μέσω μιας παραμέτρου πληροφορίες για αυτόν. (περαίτερω για αυτό σε λιγο)
        -Έχουμε την search_skipList που αναζητάει για την ύπαρξη ενός συγκεκριμένου record στην skipList, με τον καθορισμένο τρόπο των skip λιστών, ξεκινώντας την αναζήτηση από το max_level. Αν βρεθεί μέσα στην λίστα επιστρέφεται (μέσω παραμέτρου) η ημερομηνία εμβολιασμού που αναγράφεται στο record. Υπάρχει μια παράμετρος, που δίνεται απο την καλούσα συνάρτηση, η word. Αυτή είναι πίνακας συμβολοσειρών. Τα πρώτα δύο στοιχεία της περνιούνται από την καλούσα συνάρτηση και είναι το citizenID και το virusName, και το τρίτο θα είναι δείκτης στο date κάποιου συγκεκριμένου record που το γεμίζει η search_skipList και το επιστρέφει στην καλούσα της.
        -Έχουμε επίσης την get_Statistics, η οποία χρησιμοποιείται από την /populationStatus και την            /popStatusByAge και υλοποιεί αυτά που ζητούνται. 
        -Υπάρχει και η printll που εκτυπώνει κάποιο συγκεκριμένο επίπεδο μιας skipList.
        -Τέλος, έχουμε την free_skipList που αποδεσμέυει την μνήμη που δεσμέυθηκε για αυτή την δομή.
        
        

    
    Δομές Δεδομένων
    Έχουμε 4 δομές δεδομένων, την skipList, το hashTable, το bloomFilter και το DataPointer.
    
    Το hashTable υλοποιείται ως εξής:
        Έχουμε ένα struct Record το οποίο κρατάει όλη την απαραίτητη πληροφορία (δηλαδή citizenID, surname, country, age, virus, vaccinated, date και έναν δείκτη next). Αποτελείται από 10 linked λίστες στη δική μου υλοποίηση και χρησιμοποιώ την συνάρτηση my_hash(int) (από το αρχείο hashFunctions.h) για την εισαγωγή.
        
    H skipList υλοποιείται ως εξής: 
        Ως κεφαλή έχουμε έναν κόμβο Sentinel ο οποίος έχει τα πεδία:
        int NSkipLevels, που φυλάει το πλήθος των levels της συγκεκριμένης skip λίστας
        Node **next, που είναι πίνακας δεικτών σε κάθε ένα από τα επίπεδα της skip λίστας 
        και έναν ακόμη δείκτη Record *data που είναι NULL επειδή η κεφαλή δεν έχει δεδομένα (μπήκε για λόγους ομοιομορφίας)
        Οι υπόλοιποι κόμβοι υλοποιούν το struct Node και έχουν τα εξής πεδία:
        Record *data, που είναι δείκτης σε κάποιο κόμβο του hashTable έτσι ώστε να μην υπάρχει επανάληψη πληροφορίας.
        Node **next, που είναι πίνακας δεικτών όπου κάθε δείκτης είναι ή NULL ή δείχνει στο επόμενο στοιχείο του εκάστοτε level της skip λίστας.
        
    Όπως ήδη είπαμε παραπάνω για το bloomFilter δεν έχουμε ορίσει κάποια συγκεκριμένη νέα δομή, υλοποιείται με απλό πίνακα chars.
    
    Είπαμε και για το DataPointer ότι φυλάει δείκτες στα σημαντικά δεδομένα της εφαρμογής για να επιτευχθεί μεγαλύτερη αφαίρεση.
    
    
    
    
